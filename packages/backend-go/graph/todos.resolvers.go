package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"backend-go/ent"
	"backend-go/ent/todo"
	"backend-go/graph/generated"
	"backend-go/graph/model"
	"context"
	"fmt"

	"github.com/google/uuid"
)

// CreateTodo is the resolver for the createTodo field.
func (r *mutationResolver) CreateTodo(ctx context.Context, input model.CreateTodoInput) (*model.Todo, error) {
	// Use upstream mapper to prepare the creation operation
	createQuery, err := upstreamCreateTodoMapper(r.Client, input)
	if err != nil {
		return nil, err
	}

	entTodo, err := createQuery.Save(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create todo: %w", err)
	}

	// Reload with user relationship if user was set
	if input.UserID != nil {
		entTodo, err = r.Client.Todo.
			Query().
			Where(todo.ID(entTodo.ID)).
			WithUser().
			Only(ctx)
		if err != nil {
			return nil, fmt.Errorf("failed to reload todo with user: %w", err)
		}
	}

	// Use downstream mapper to convert to GraphQL model
	return downstreamTodoMapper(entTodo), nil
}

// UpdateTodo is the resolver for the updateTodo field.
func (r *mutationResolver) UpdateTodo(ctx context.Context, input model.UpdateTodoInput) (*model.Todo, error) {
	// Use upstream mapper to prepare the update operation
	updateQuery, err := upstreamUpdateTodoMapper(r.Client, input)
	if err != nil {
		return nil, err
	}

	entTodo, err := updateQuery.Save(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return nil, fmt.Errorf("todo with id %s not found", input.ID)
		}
		return nil, fmt.Errorf("failed to update todo: %w", err)
	}

	// Use downstream mapper to convert to GraphQL model
	return downstreamTodoMapper(entTodo), nil
}

// DeleteTodo is the resolver for the deleteTodo field.
func (r *mutationResolver) DeleteTodo(ctx context.Context, id string) (bool, error) {
	todoID, err := uuid.Parse(id)
	if err != nil {
		return false, fmt.Errorf("invalid todo ID: %w", err)
	}

	err = r.Client.Todo.DeleteOneID(todoID).Exec(ctx)
	if err != nil {
		if ent.IsNotFound(err) {
			return false, nil // Todo didn't exist, but that's okay
		}
		return false, fmt.Errorf("failed to delete todo: %w", err)
	}

	return true, nil
}

// Todos is the resolver for the todos field.
func (r *queryResolver) Todos(ctx context.Context) ([]*model.Todo, error) {
	entTodos, err := r.Client.Todo.Query().
		WithUser(). // Load user relationship
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to query todos: %w", err)
	}

	// Use downstream mapper to convert to GraphQL models
	todos := make([]*model.Todo, len(entTodos))
	for i, entTodo := range entTodos {
		todos[i] = downstreamTodoMapper(entTodo)
	}

	return todos, nil
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
